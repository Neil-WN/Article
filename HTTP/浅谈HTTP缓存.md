# 浅谈HTTP缓存

## 前言

作为一名开发者，无论是在Web开发过程中亦或是在工作面试的时候，总会绕不过一个主题——HTTP协议。HTTP是TCP/IP协议的应用层协议，在开发和应用中都少不了和它打交道，如页面跳转、接口请求等。HTTP协议涉及的内容很多，URI、请求方式、状态码、协议版本等，每一个单独拿出来讲都是可以写一篇文章，而今天主要讲述的是HTTP缓存，希望通过本文，能让大家对HTTP缓存有个基本的认识。

## 背景

在互联网时代，尤其是在移动互联网中，网络请求资源的大小和请求的次数是影响用户体验的重要指标。因此，许多开发者在做性能优化的时候会针对这两个指标进行处理，如压缩请求资源的大小、减少网络请求的次数等，但对于一些需要重复请求的资源（用户需要下载的文件、固定的背景图片等），则通过以上方法无法做到最优的优化方式，因此，比较好的选择就是使用HTTP缓存技术，当用户需要请求固定的资源时，无须每次都向服务器请求资源，而仅需从缓存中拿到所需资源即可。

总的来说，使用HTTP缓存具有以下优点：

1. 减少了冗余的数据传输，节省了用户的流量
2. 减少了网络带宽的使用和降低请求的时延，更快地加载页面
3. 减少了请求的次数，缓解了服务器的压力

## 缓存处理过程

一般，HTTP缓存的工作原理都比较简单，以下则以请求背景图片graph1@2x.png的例子来了解一下HTTP请求和缓存处理的基本过程，如下时序图所示。

```sAJHEFXJ9A4W3equence
Title: 客户端第一次请求数据
客户端->缓存区: 请求图片graph1@2x.png
缓存区->客户端: 没有缓存这张图片
客户端->服务器: 请求图片graph1@2x.png
服务器->缓存区: 将图片存入缓存
服务器->客户端: 200，返回图片graph1@2x.png
```

当用户发送请求时，首先会向缓存区查询是否有该图片，如果没有则向服务器请求数据，待服务器处理后，返回200状态码，返回数据到客户端的同时，将数据存入缓存区中，在下一次请求同一资源的时候，就可以直接从缓存区中读取数据。

![200 noCache](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_200_nocache.png?raw=true)

## 强缓存

首次请求完成后，缓存区中已经存有了这张图片。那么，当客户端再次请求graph1@2x.png这张图片的时候，还是会先向缓存区中请求图片数据，此时，就会将缓存区的graph1@2x.png图片返回给客户端，如下时序图所示：

```sequence
Title: 强缓存命中
客户端->缓存区: 再次请求图片graph1@2x.png
缓存区->客户端: 没有缓存这张图片
```

缓存区中有请求所需的数据，就可以直接从中获取相关的数据。有些同学就会有疑问，如果服务器更新了这张图片，那么客户端还是每次都从缓存区中获取这张图片，那不是出错了吗？是的，此时这种情况的确有问题，但强大的HTTP协议又如何会忽略这种情况呢？它为服务器的响应头中提供了Expires和Cache-Control（开发人员可以自行设置），用于判断该图片是否过期。

### Expires

Expires是HTTP/1.0的产物，它指定了一个绝对的过期时间，它会与当前的时间进行对比，如果过了Expires时间，则说明该缓存数据不再使用。Expires的格式类似如`Expires: Sun, 02 Sep 2018, 01:00:00 GMT`，表示2018年9月2日1时过期。

### Cache-Control

Cache-Control是HTTP/1.1的产物，它指定的是一个相对时间，即在缓存区中第一次生成缓存数据到该缓存数据过期的时间，以秒为单位。Cache-Control的格式类似如`Cache-Control: max-age=3600`，表示最大的存活时间为1小时。Cache-Control与Expires的作用一致，当两者同是设置时，前者的优先级高于后者。

Cache-Control的值除了max-age外，还有其他的值供选择，常用的值如下表所示：

| 值        | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| public    | 响应数据可被任何缓存区缓存                                   |
| private   | 缓存区中数据只能被单个用户使用，而不能被其它用户使用         |
| no-cache  | 除非资源进行了再验证（协商缓存），否则这个客户端不会接受已缓存的资源 |
| no-store  | 请求和响应数据都不使用任何缓存                               |
| max-age   | 客户端可以在生存期不大于指定的时间内获取缓存                 |
| min-fresh | 客户端可以接收响应时间小于当前时间加上指定时间的响应         |
| max-stale | 客户端可以接收超出超时期间的响应消息                         |

在强缓存命中后，请求的状态码依然是200，区别在于图片是从缓存中获取的，如下图所示：

![](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_200_fromcache.png?raw=true)

## 协商缓存

当强缓存没有命中时，此时客户端会发送请求到服务器进行判断缓存区的缓存资源是否可用，此过程称为协商缓存，具体过程如下所示：

```sequence
Title: 协商缓存命中
客户端->缓存区: 请求图片graph1@2x.png
缓存区->客户端: 缓存过期
客户端->服务器: 请求图片graph1@2x.png
服务器->客户端: 304，请求的图片没变
缓存区->客户端: 返回graph1@2x.png
```

协商缓存的命中与否，与强缓存相似，也需要通过几个响应头首部作为判断，总体可以分成两组——“Last-Modified/If-Modified-Since”和"Etag/If-None-Match"。

### Last-Modified / If-Modified-Since

Last-Modified表示该响应资源的最后修改时间，格式类似为`Last-Modified: Sun, 02 Sep 2018, 01:00:00 GMT`。

If-Modified-Since是指强缓存未命中，该资源带有Last-Modified首部，则再次向服务器请求资源时带上If-Modified-Since首部。当服务器收到请求后，发现首部带有If-Modified-Since字段，则与被请求资源的最后修改时间（Last-Modified）进行比对。如果Last-Modified的时间大于If-Modified-Since的时间，说明请求的资源被修改过，则返回最新的资源和200状态码；如果Last-Modified的时间小于If-Modified-Since的时间，说明请求的资源未被修改，则返回304状态码，让客户端继续使用缓存区的资源。

### ETag / If-None-Match

ETag是服务器响应请求时，在响应头中用于确认当前资源在服务器的唯一标识，该标识的生成规则由服务器所决定。

If-None-Match是在强缓存未命中时，该资源带有ETag首部，则再次向服务器请求资源时带上If-None-Match首部。当服务器收到请求后，发现首部带有If-None-Match字段，则与ETag字段进行比对。如果两个字段的值不同，说明资源被修改过，则返回最新的资源和200状态码；否则，说明请求的资源未被修改，则返回304状态码，让客户端继续使用缓存区的资源。

下图所示的是响应头，该头部包含了协商缓存的字段：

![](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_response.png?raw=true)

### Last-Modified与Etag的区别

细心的同学会发现，既然通过判断Last-Modified就足以让客户端知道缓存区的资源是否过期，那么为什么还需要ETag头部呢？其实ETag还是大有用武之地的：

1. Last-Modified使用的是绝对时间，且精确到1秒，当在1秒内被多次修改了请求资源，那么客户端获取的资源则有可能是未更新的。
2. 有些文档可能会被周期性重写，可能内容没有变化，但Last-Modified的时间却改变了。
3. 有些服务器无法准确地判定其资源的最后修改时间。

因此，通过ETag能够更准确判断资源是否被修改且比对的效率更高。当Last-Modified首部和ETag首部同时使用时，服务器会优先验证ETag，如果ETag都无法匹配，则说明请求的资源发生了更新，则无须再比对Last-Modified字段，直接返回200，返回新的请求资源；在与If-None-Match字段的值一致的情况下，才会继续比对Last-Modified，最后才决定返回状态码304还是200。

## F5与Ctrl+F5

F5和Ctrl+F5都是进行浏览器刷新页面的操作，但是两者的处理过程却大不相同。

使用F5进行页面刷新时，浏览器会执行一次完整的缓存处理过程，请求头部如下图所示：

![cache_request_F5.png](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_request_F5.png?raw=true)

而Ctrl+F5是指强制刷新当前页面，即不使用缓存，此时浏览器会发送一个带有**Pragma: no-cache**请求头部，即不使用缓存资源，则服务器会返回这个资源和状态码200，如下图所示：

![cache_request_CtrlF5.png](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_request_CtrlF5.png?raw=true)

## 总结

当客户端第一次请求资源时，缓存区没有该资源的缓存，客户端会向服务器发起请求，服务器接收到请求后会返回所需资源和状态码200，并将该资源缓存在缓存区中。

当客户端需要再次请求该资源时，首先会在缓存区中查找是否有该资源的缓存，如果有，则判断Expire / Cache-Control是否过期，如果没有过期，即是强缓存命中，客户端直接从缓存区获取资源；如果强缓存未命中，客户端会向服务器请求该资源，此时首先判断ETag（如果存在）是否匹配，如果不匹配，则服务器返回响应资源和状态码200；如果匹配，则继续判断Last-Modified的时间是否过期，如果过期，则同样返回响应资源和状态码200，否则返回状态码304，客户端则会继续从缓存中获取资源。

具体的流程图如下所示：

![cache_flow.png](https://github.com/Neil-WN/MarkdownPhotos/blob/master/images/cache_flow.png?raw=true)


*** 本文是个人对HTTP缓存的浅显理解，如有错误，还请批评指正。